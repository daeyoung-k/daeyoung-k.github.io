---
title: 트랜잭션 커밋 지연 문제
author: kane
date: 2025-10-27
categories:
  - Backend
  - Kotlin
  - Spring
tags:
  - 학습기록
  - Transactional
render_with_liquid: false
pin: false
description: 
---
>Spring boot 트랜잭션 커밋 지연 문제를 파악합니다.
  
회사에서 고객 접수 api를 활용하는 api를 개발하면서 트랜잭션 관련 어려움이 있었습니다.  
기존의 고객 접수 api는 Django 서버에 있고 새로 개발하는 api는 Spring boot에 개발하였습니다.  
  
Spring boot에서 데이터를 테이블에 저장하고 생성된 id(Long) 값을 바로 Django 서버로 전달하여 기존의 로직을 실행하도록 하는 과정에서 Spring boot의 트랜잭션으로 인해 Django 서버가 id 값을 찾지 못하여 오류가 발생하였습니다.

---
## 영속성 컨텍스트(Persistence Context)와 트랜잭션의 지연된 커밋

| **구분** | **Spring Boot (Kotlin) 동작**                                                                                   |                                 **Django (Python) 동작** |
| :------- | :-------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------: |
| **정상** | 1. 고객 데이터 저장<br>2. **DB 커밋 완료**<br>3. Django 서버 호출                                               |       `id`를 받아 DB에서 조회가 가능하므로 **정상 작동** |
| **오류** | 1. 고객 데이터 저장<br>2. `save()`는 영속성 컨텍스트에만 저장<br>3. **DB 커밋은 지연됨**<br>4. Django 서버 호출 | `id`를 받았으나 **DB에 아직 커밋되지 않아** 조회가 안 됨 |

- **DB에 실제로 쓰여지는 시점**이 외부 API 호출 시점보다 늦었기 때문에 발생한 문제입니다.

---
## 해결 시도

1. @Transactional 어노테이션을 사용하지 않고, 코드 내에서 직접 트랜잭션의 시작(getTransaction), 종료(commit), 그리고 롤백(rollback)을 명시적으로 호출
```kotlin
    import org.springframework.transaction.support.DefaultTransactionDefinition
   
    private val transactionManager: PlatformTransactionManager,
   
    @PersistenceContext     
    private lateinit var entityManger: EntityManager
   
    fun saveQueryHistory(queryHistory: QueryHistory): QueryHistory {  
  
	  val status = transactionManager.getTransaction(DefaultTransactionDefinition())  
	  return try {  
		entityManger.persist(queryHistory)  
		entityManger.flush()  
	  
		transactionManager.commit(status)  
		queryHistory  
	  } catch (e: Exception) {  
		transactionManager.rollback(status)  
		throw e  
	  }  
	}
```

- transactionManager.getTransaction(...): 이 코드가 실행되는 순간, 새로운 트랜잭션이 시작됩니다.
  

1. Spring에서 가장 흔하게 사용되는 **선언적 트랜잭션 관리(Declarative Transaction Management)**
```kotlin
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    fun saveQueryHistory(queryHistory: QueryHistory) = queryRepository.save(queryHistory)
```

- @Transactional(propagation = Propagation.REQUIRES_NEW): 이 메소드가 호출되면 항상 새로운 트랜잭션을 시작하라는 의미입니다. 만약 이 메소드를 호출한 다른 서비스 메소드에 이미 진행 중인 트랜잭션이 있더라도, 그 트랜잭션은 잠시 멈추고 완전히 새로운 트랜잭션이 만들어집니다. 메소드가 종료될 때 이 새로운 트랜잭션은 커밋되거나 롤백됩니다.

1. 2번과 마찬가지로 선언적 트랜잭션을 사용하지만, Spring Data JPA의 save 메소드 대신 순수 JPA의 EntityManager를 직접 사용
```kotlin
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    fun saveQueryHistory(queryHistory: QueryHistory): QueryHistory {
        entityManger.persist(queryHistory)
        entityManger.flush()
    return queryHistory
    }
```

- 2번과 마찬가지로 선언적 트랜잭션을 사용하지만, Spring Data JPA의 save 메소드 대신 순수 JPA의 EntityManager를 직접 사용

---
## 해결 유무

결과는 **트랜잭션 문제 해결 실패**  
위의 3가지 방식을 사용해도 **DB에 실제로 쓰여지는 시점**이 외부 API 호출 시점보다 계속 느려서 오류가 발생하였습니다.  
추후에 `Django` 서버의 api를 모두 `Spring boot`로 이관하고 하나의 프레임워크로 통일하여 유지보수성을 높이려는 전략이 있어서 최대한 Django 서버를 건들이지 않으려는 이유로 Spring boot 서버에 개발하려고 했습니다.  
- 이벤트 기반도 고민
	- Spring boot에서 고객 정보만 저장 후 이벤트 발행 (트랜잭션 문제 해결)
	- 구독중인 서비스가 Django 서버를 호출하여 정보처리

하지만 **동기적 흐름의 필수성**, 저장된 데이터의 id 값을 django 서버에 요청 하여 실행 된 결과 정보가 필수적으로 return 되어야 하는 이유로 맞지 않았습니다.  
(해당 로직을 Spring 으로 옮기기엔 시간이 부족함)  
  
그래서 native query 를 사용하여 insert 문을 직접 날려볼까 고민해보았지만 유지보수성을 높이려고 작업하는 것인데 더 나쁜 상태로 만들어 버리는것 같아 적용하지 않았습니다.  
결국은 `Spring boot` 를 사용하지 않고 `Django` 서버의 api 를 수정하여 사용하도록 하였습니다.    


---
## 배운 점 

- `@Transactional`의 동작 원리 재확인: @Transactional 어노테이션이 붙은 메소드가 완전히 종료되어야 트랜잭션이 커밋된다는 점을 몸소 체험했습니다. 메소드 내부에서 외부 API를 호출하는 시점에는 아직 데이터가 다른 트랜잭션에 보이지 않는다는 것을 명확히 알게 되었습니다.
- `flush()`는 `commit()`이 아니다: EntityManager.flush()는 영속성 컨텍스트의 변경 내용을 DB에 보내는 역할일 뿐, 트랜잭션을 확정하는 commit()과는 다르다는 것을 깨달았습니다. 이 때문에 flush()를 호출해도 외부 시스템에서는 데이터를 즉시 조회할 수 없었습니다.

## 회고

- 이번 문제를 통해 Spring의 트랜잭션 관리에 대해 표면적으로만 알고 있었다는 점을 반성하게 되었습니다. 앞으로 트랜잭션의 격리 수준(Isolation Level)과 전파 속성(Propagation)에 대해 더 깊이 학습하여 내부 동작 원리를 완벽히 이해해야겠습니다.
- 기술적인 완벽함만을 추구하기보다, 현재 상황(시간, 리소스, 팀의 기술 스택)을 고려하여 가장 실용적인 해결책을 선택하는 것의 중요성을 다시 한번 느꼈습니다. 결국 Django API를 수정하기로 한 결정은 최선은 아니었지만, 당시로서는 가장 합리적인 선택이었습니다.

---


